// User defined generic function that operates on unknown shaped arguments.
fn multiply_transpose(a, b) {
    return transpose(a) * transpose(b);
}

fn main() {
    // Define a variable `a` with shape <2, 3>, initialized with the literal value.
    let a = [[1, 2, 3], [4, 5, 6]];
    let b<2, 3> = [1, 2, 3, 4, 5, 6];

    // This call will specialize `multiply_transpose` with <2, 3> for both
    // arguments and deduce a return type of <3, 2> in initialization of `c`.
    let c = multiply_transpose(a, b);

    // A second call to `multiply_transpose` with <2, 3> for both arguments will
    // reuse the previously specialized and inferred version and return <3, 2>.
    let d = multiply_transpose(b, a);

    // A new call with <3, 2> (instead of <2, 3>) for both dimensions will
    // trigger another specialization of `multiply_transpose`.
    let e = multiply_transpose(c, d);

    // Finally, calling into `multiply_transpose` with incompatible shapes
    // (<2, 3> and <3, 2>) will trigger a shape inference error.
    let f = multiply_transpose(a, c);
}